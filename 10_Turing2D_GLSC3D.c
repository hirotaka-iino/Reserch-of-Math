/******************************************************************************************
 
 This program solves reacrtion-diffusion equations using the explicit method.
 
 Reacrtion-diffusion equations are ut = du uxx + f(u,v) and vt = dv vxx + g(u,v).
 
 Time loop in this program consists of
 "Calculation part" and "Draw Part".
 
 Calculation part is controlled by the interval parameter INTV.
 
*******************************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include "glsc3d_3.h"

#define N (100)
#define M (100)

double a = 3.0;//3.0;
double b = 2.0;//2.0;
double c = 0.0;//0.0;
double d = 1.0;//1.0;

//double a = 0.0;//3.0;
//double b = 0.0;//2.0;
//double c = 0.0;//0.0;
//double d = 0.0;//1.0;

double f(double u, double v){ return d * (u * (1 - u * u) - v);}
double g(double u, double v){ return a * (u - c) - b * v;}
void g_color_map(double Array[][M+2],
                 double dx_width, double dy_width,
                 double L_bottom_x, double L_bottom_y,
                 double max, double min
                 );
double rand_range(double min,double max){ return (max - min) * (rand()) / RAND_MAX + min;}

int main(void)
{
    double  Lx = 100.0;
    double  Ly = 100.0;
    double  dx = Lx / N;
    double  dy = Ly / M;
    double  dt = 0.001;
    double  du = 1.0;
    double  dv = 10.0;
    
    double  lambda_u = du * dt / (dx * dx);
    double  lambda_v = dv * dt / (dy * dy);
    
    double  u0[N + 2][M + 2];
    double  u1[N + 2][M + 2];
    double  v0[N + 2][M + 2];
    double  v1[N + 2][M + 2];
    
    int INTV = 200;
    
    double WINDOW_SIZE_X = 800;
    double WINDOW_SIZE_Y = 600;
    g_init("Turing Simulator", WINDOW_SIZE_X, WINDOW_SIZE_Y);    //Pixel Size

    g_def_scale_2D(0,                   //ID
                   -Lx*0.5, Lx*0.5,		//xmin,xmax
                   -Ly*0.5, Ly*0.5,     //ymin,ymax
                   20.0, 20.0,          //Window (Left, Top) Position
                   560, 560);           //Window Size (x,y)
    //Set initial calculation
    {
        //Step1
        double u_Init_Sum = 0.0;
        double v_Init_Sum = 0.0;
        
        unsigned int seed = 19830413;   //Seed for random number generated by rand()
        srand(seed);
        
        for(int j = 1;j < M + 1; j ++)
        {
            for(int i = 1;i < N + 1; i ++)
            {
                double Max =  1.0; //Maximum of random number
                double Min = -1.0; //Minimum of random number
                u0[i][j] = rand_range(Min,Max);
                v0[i][j] = rand_range(Min,Max);
                
                u_Init_Sum += u0[i][j] * dx * dy;
                v_Init_Sum += v0[i][j] * dx * dy;
            }
        }
		//printf("Initial Volume (u, v) = (%15.15f,%15.15f)\n",u_Init_Sum,v_Init_Sum);
        
        //Step2
        for(int j = 1;j < M + 1; j ++)
        {
            u0[0][j] = u0[N][j];
            u0[N + 1][j] = u0[1][j];
            v0[0][j] = v0[N][j];
            v0[N + 1][j] = v0[1][j];
        }
        for(int i = 0;i < N + 2; i ++)
        {
            u0[i][0] = u0[i][M];
            u0[i][M + 1] = u0[i][1];
            v0[i][0] = v0[i][M];
            v0[i][M + 1] = v0[i][1];
        }
    }

    //////////// Start time loop ////////////
    for (int i_time = 0; ; i_time++)
	{
        //////////// Draw Part ////////////
        if (i_time%INTV == 0) {
            g_cls();					//Clear window
            //text
            {
                g_text_size(16);
                g_text_color(0, 0, 0, 1);
                
                double TextLeft = 610.0;
                double TextTop = 40.0;
                double TextWidth = 30.0;
                int IncrimentTextWidth = 0;
                
                g_text_standard(TextLeft, TextTop + TextWidth*(IncrimentTextWidth ++),"u_t = Du∇・∇u + f(u,v)");
                g_text_standard(TextLeft, TextTop + TextWidth*(IncrimentTextWidth ++),"v_t = Dv∇・∇v + g(u,v)");
                g_text_standard(TextLeft, TextTop + TextWidth*(IncrimentTextWidth ++)," ");
                g_text_standard(TextLeft, TextTop + TextWidth*(IncrimentTextWidth ++),"f(u,v)=d ( u(1 - u*u) - v )");
                g_text_standard(TextLeft, TextTop + TextWidth*(IncrimentTextWidth ++),"g(u,v)=a ( u - c ) - b v");
                g_text_standard(TextLeft, TextTop + TextWidth*(IncrimentTextWidth ++)," ");
                g_text_standard(TextLeft, TextTop + TextWidth*(IncrimentTextWidth ++),"a = %f",a);
                g_text_standard(TextLeft, TextTop + TextWidth*(IncrimentTextWidth ++),"b = %f",b);
                g_text_standard(TextLeft, TextTop + TextWidth*(IncrimentTextWidth ++),"c = %f",c);
                g_text_standard(TextLeft, TextTop + TextWidth*(IncrimentTextWidth ++),"d = %f",d);

                g_text_standard(TextLeft, TextTop + TextWidth*(IncrimentTextWidth ++),"Step is %d",i_time);
                g_text_standard(WINDOW_SIZE_X * 0.46, WINDOW_SIZE_Y * 0.99, "Copyright ©2019 Masakazu AKIYAMA. All rights reserved");

            }
            
            g_sel_scale(0);				//Select Virtual scale
            g_line_color(0.0, 0.0, 0.0, 1.0);
            g_boundary();				//Draw Boundary
            
            g_line_color(1.0, 0.0, 0.0, 1.0);
            // g_contln_2D(-Lx*0.5 + dx*0.5, Lx*0.5 - dx*0.5, -Ly*0.5 + dy*0.5, Ly*0.5 - dy*0.5, N+2, M+2, u0, 0.0); //Contln_0.0
            g_color_map(u0, dx, dy, -Lx*0.5 + dx * 0.5, -Ly*0.5 + dy * 0.5, 0.2, -0.2);
            
            g_finish();					//flush Draw buffer
            g_sleep(0.1);				//Sleep 0.01 sec
        }
        
        //////////// Calculation Part ////////////
        {
            //Step3
            for(int j = 1;j < M + 1; j ++)
            {
                for(int i = 1;i < N + 1; i ++)
                {
                    u1[i][j] = u0[i][j]
                    + lambda_u * (u0[i - 1][j] - 2 * u0[i][j] + u0[i + 1][j])
                    + lambda_u * (u0[i][j - 1] - 2 * u0[i][j] + u0[i][j + 1])
                    + dt * f(u0[i][j], v0[i][j]);
                    
                    v1[i][j] = v0[i][j]
                    + lambda_v * (v0[i - 1][j] - 2 * v0[i][j] + v0[i + 1][j])
                    + lambda_v * (v0[i][j - 1] - 2 * v0[i][j] + v0[i][j + 1])
                    + dt * g(u0[i][j], v0[i][j]);
                }
            }
            //Step4
            for(int j = 1;j < M + 1; j ++)
            {
                for(int i = 1;i < N + 1; i ++)
                {
                    u0[i][j] = u1[i][j];
                    v0[i][j] = v1[i][j];
                }
            }
            //Step5
            for(int j = 1;j < M + 1; j ++)
            {
                u0[0][j] = u0[N][j];
                u0[N + 1][j] = u0[1][j];
                v0[0][j] = v0[N][j];
                v0[N + 1][j] = v0[1][j];
            }
            for(int i = 0;i < N + 2; i ++)
            {
                u0[i][0] = u0[i][M];
                u0[i][M + 1] = u0[i][1];
                v0[i][0] = v0[i][M];
                v0[i][M + 1] = v0[i][1];
            }
        }

		//////////// Sum Part ////////////
        if(0)
		{
			double u_Init_Sum = 0.0;
			double v_Init_Sum = 0.0;
			for(int j = 1;j < M + 1; j ++)
			{
				for(int i = 1;i < N + 1; i ++)
				{
					u_Init_Sum += u0[i][j] * dx * dy;
					v_Init_Sum += v0[i][j] * dx * dy;
				}
			}
			printf("Volume (u, v) = (%15.15f,%15.15f)\n",u_Init_Sum,v_Init_Sum);
		}
    }
	return 0;
}

//////////// Color map: g_color_map ////////////
void g_color_map(double Array[][M+2],
                 double dx_width, double dy_width,
                 double L_bottom_x, double L_bottom_y,
                 double max, double min
                 )
{
    int Fine_Grid = 1;
    for (int j=0; j < M+2; j++) {
        for (int i=0; i < N+2; i++) {
            if (Fine_Grid == 0) {
                g_area_color((Array[i][j]-min)/(max-min), 0, 1.0-(Array[i][j]-min)/(max-min), 0.5);
                g_box_center_2D(dx_width * (i) + L_bottom_x, dy_width * (j) + L_bottom_y, dx_width, dy_width, G_NO, G_YES);
            }
            
            if (Fine_Grid == 1) {
                double tmpColor;
                if (j-1<0) tmpColor = Array[i][j];
                else tmpColor = Array[i][j]*0.5 + Array[i][j-1]*0.5;
                g_area_color((tmpColor-min)/(max-min), 0, 1.0-(tmpColor-min)/(max-min), 1);
                g_triangle_2D(dx_width * (i) + L_bottom_x, dy_width * (j) + L_bottom_y,
                              dx_width * (i) + L_bottom_x - dx_width*0.5, dy_width * (j) + L_bottom_y - dy_width*0.5,
                              dx_width * (i) + L_bottom_x + dx_width*0.5, dy_width * (j) + L_bottom_y - dy_width*0.5,
                              G_NO, G_YES);
                
                if (i+1>=N+2) tmpColor = Array[i][j];
                else tmpColor = Array[i][j]*0.5 + Array[i+1][j]*0.5;
                g_area_color((tmpColor-min)/(max-min), 0, 1.0-(tmpColor-min)/(max-min), 1);
                g_triangle_2D(dx_width * (i) + L_bottom_x, dy_width * (j) + L_bottom_y,
                              dx_width * (i) + L_bottom_x + dx_width*0.5, dy_width * (j) + L_bottom_y - dy_width*0.5,
                              dx_width * (i) + L_bottom_x + dx_width*0.5, dy_width * (j) + L_bottom_y + dy_width*0.5,
                              G_NO, G_YES);
                
                if (j+1>=M+2) tmpColor = Array[i][j];
                else tmpColor = Array[i][j]*0.5 + Array[i][j+1]*0.5;
                g_area_color((tmpColor-min)/(max-min), 0, 1.0-(tmpColor-min)/(max-min), 1);
                g_triangle_2D(dx_width * (i) + L_bottom_x, dy_width * (j) + L_bottom_y,
                              dx_width * (i) + L_bottom_x + dx_width*0.5, dy_width * (j) + L_bottom_y + dy_width*0.5,
                              dx_width * (i) + L_bottom_x - dx_width*0.5, dy_width * (j) + L_bottom_y + dy_width*0.5,
                              G_NO, G_YES);
                
                if (i-1<0) tmpColor = Array[i][j];
                else tmpColor = Array[i][j]*0.5 + Array[i-1][j]*0.5;
                g_area_color((tmpColor-min)/(max-min), 0, 1.0-(tmpColor-min)/(max-min), 1);
                g_triangle_2D(dx_width * (i) + L_bottom_x, dy_width * (j) + L_bottom_y,
                              dx_width * (i) + L_bottom_x - dx_width*0.5, dy_width * (j) + L_bottom_y + dy_width*0.5,
                              dx_width * (i) + L_bottom_x - dx_width*0.5, dy_width * (j) + L_bottom_y - dy_width*0.5,
                              G_NO, G_YES);
            }
        }
    }
}
